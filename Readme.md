# Machine Learning on MSP430

Sample project of a Machine Learning algorithm running on MSP430FR5994 launchpad.

## Algorithm

The algorithm is an adaptation of the AEP algorithm for the MSP430 FR5994 controller, in particular the changes involve the memory usage of the algorithm in order to afford the memroy constraints of the device. For instance, the `int` type is changed with the `uint16_t` type implemented in the `stdint.h` library; another important type modification is the float, that is the main memory harvesting type because of the implementation of the dataset, and it is changed with the `fixed` type implemented in the `fixed.h` library (from libfixed).

At the moment the algorithms working are **k-means** algorithm, the **k-Nearest Neighbor**, **Decision Tree**, that are the original algorithms implemented in the AEP, and additionally has been implemented the **Perceptron** algorithm.

Other modifications has been made to avoid dynamic memory allocation, in this algorithm only statically-allocated variables or structs are provided.

## Dataset

There has been used different Dataset in order to try the potentiality of the algorithm over different data types. The size of the dataset is of 778 samples, that are split into 80% training set and 20% test set. As result, we have a training set composed of 654 samples, and a training set composed of 154 samples.

Here is a list of the datasets:

- [**Pima Indians Diabetes Database**](https://www.kaggle.com/datasets/uciml/pima-indians-diabetes-database): This dataset is originally from the National Institute of Diabetes and Digestive and Kidney Diseases. The objective of the dataset is to diagnostically predict whether or not a patient has diabetes, based on certain diagnostic measurements included in the dataset.
- [**MotionSense Dataset: Smartphone Sensor Data - HAR**](https://www.kaggle.com/datasets/malekzadeh/motionsense-dataset): This dataset includes time-series data generated by accelerometer and gyroscope sensors (attitude, gravity, userAcceleration, and rotationRate).
- [**Accelerometer Dataset**](https://www.kaggle.com/datasets/dhinaharp/accelerometer-data-set): This dataset was generated for use on 'Prediction of Motor Failure Time Using An Artificial Neural Network' project (DOI: 10.3390/s19194342). A cooler fan with weights on its blades was used to generate vibrations. To this fan cooler was attached an accelerometer to collect the vibration data.
- [**Sensor Readings with wall-following robot**](https://www.kaggle.com/datasets/uciml/wall-following-robot?select=sensor_readings_4.csv): The data were collected as the SCITOS G5 navigated through the room following the wall in a clockwise direction, for 4 rounds.

### Pima Indians Diabetes Database

This dataset is the one used in the original AEP algorithm, it has been used in order to compare the results of the algorithm over different devices. So, the samples and the features are the same.

### MotionSense Dataset: Smartphone Sensor Data - HAR

This dataset has been used in order to do Human Activity Recognition. A total of 24 participants in a range of gender, age, weight, and height performed 6 activities in 15 trials in the same environment and conditions: downstairs, upstairs, walking, jogging, sitting, and standing.

Since the algorithms provided is not designed for multiclass classification, this dataset is used to predict the activity over two different classes, for instance sitting vs walking.

The features used for this dataset are the one provided by the attitude (roll, yaw and pitch) and gravity (x, y, z) senors, because they give the position of the phone in a certain time. In order to make the user acceleration and rotation rate data useful for the algorithm, some calculations are needed, in particular, there has been calculated the euclidean distance of the point and the origin point, that is the point that states that the phone is not moving. In this way the feature can be used to see if the user is moving or not.

For each sample s, the user acceleration feature of s has been computed with the formula:
$$ A = \sqrt{s_x^2 + s_y^2 + s_z^2} $$
Similarly, the rotation rate has been calculated with the following formula:
$$ RR = \sqrt{s_x^2 + s_y^2 + s_z^2} $$

### Accelerometer Dataset

To generate three distinct vibration scenarios, the weights were distributed in three different ways:

1) 'red' - normal configuration: two weight pieces positioned on neighboring blades;
2) 'blue' - perpendicular configuration: two weight pieces positioned on blades forming a 90Â° angle;
3) 'green' - opposite configuration: two weight pieces positioned on opposite blades.

This dataset provides three features extracted from the accelerometer (x, y, and z), so the only feature used is the distance of the sample, in order to see how much it vibrates.

### Sensor Readings with wall-following robot

To navigate, the robot uses 24 ultrasound sensors arranged circularly around its "waist". The numbering of the ultrasound sensors starts at the front of the robot and increases in clockwise direction. For this project, it has been used a simplified version of the dataset, that contains four sensor readings named 'simplified distances' and the corresponding class label l (Moving forward, turning left, etc). These simplified distances are referred to as the 'front distance', 'left distance', 'right distance' and 'back distance'. They consist, respectively, of the minimum sensor readings among those within 60 degree arcs located at the front, left, right and back parts of the robot.

For this dataset there has been used different couples of different classes for classifications, in order to see the performance over different activity classification.

## Results

Results has been collected in the [Results Excel file](https://docs.google.com/spreadsheets/d/1A6-PKLFHJk3KmczFO7_IClG042DX3PduE0NoQGsT_CA/edit?usp=sharing), where the performance has been measured for each iteration of the algorithm (namely, for each update of the samples in memory). The number of iterations depends on the memory and update sizes, that are set to 100 samples and 50 samples respectively.

## Usage

The main usage difference against the original AEP algorithm is the possibility of using the `DEBUG` label in order to print some information in the console, in this way it is possible to debug the code during the execution.

## References

- [AEP](https://github.com/Edge-Learning-Machine/AEP) - The original AEP algorithm.
- [libfixed](https://github.com/CMUAbstract/libfixed/tree/b6a5caf12468fd4d573f17f1984706e1b9f5bcc0) - The libfixed library.
